#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0
import argparse
import os
import shlex
import shutil
import subprocess
import sys
from lib.python_version import PythonVersion

LIB_DIR = "../../scripts/lib"
SRC_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, os.path.join(SRC_DIR, LIB_DIR))

from jobserver import JobserverExec

MIN_PYTHON_VERSION = PythonVersion("3.7").version
PAPER = ["", "a4", "letter"]
TARGETS = {
    "cleandocs":     { "builder": "clean" },
    "linkcheckdocs": { "builder": "linkcheck" },
    "htmldocs":      { "builder": "html" },
    "epubdocs":      { "builder": "epub",    "out_dir": "epub" },
    "texinfodocs":   { "builder": "texinfo", "out_dir": "texinfo" },
    "infodocs":      { "builder": "texinfo", "out_dir": "texinfo" },
    "latexdocs":     { "builder": "latex",   "out_dir": "latex" },
    "pdfdocs":       { "builder": "latex",   "out_dir": "latex" },
    "xmldocs":       { "builder": "xml",     "out_dir": "xml" },
}

class SphinxBuilder:
    def is_rust_enabled(self):
        config_path = os.path.join(self.srctree, ".config")
        if os.path.isfile(config_path):
            with open(config_path, "r", encoding="utf-8") as f:
                return "CONFIG_RUST=y" in f.read()
        return False

    def get_path(self, path, use_cwd=False, abs_path=False):
        path = os.path.expanduser(path)
        if not path.startswith("/"):
            if use_cwd:
                base = os.getcwd()
            else:
                base = self.srctree
            path = os.path.join(base, path)
        if abs_path:
            return os.path.abspath(path)
        return path

    def __init__(self, builddir, verbose=False, n_jobs=None):
        self.verbose = None
        self.kernelversion = os.environ.get("KERNELVERSION", "unknown")
        self.kernelrelease = os.environ.get("KERNELRELEASE", "unknown")
        self.pdflatex = os.environ.get("PDFLATEX", "xelatex")
        self.latexopts = os.environ.get("LATEXOPTS", "-interaction=batchmode -no-shell-escape")
        if not verbose:
            verbose = bool(os.environ.get("KBUILD_VERBOSE", "") != "")
        if verbose is not None:
            self.verbose = verbose
        parser = argparse.ArgumentParser()
        parser.add_argument('-j', '--jobs', type=int)
        parser.add_argument('-q', '--quiet', type=int)
        sphinxopts = shlex.split(os.environ.get("SPHINXOPTS", ""))
        sphinx_args, self.sphinxopts = parser.parse_known_args(sphinxopts)
        if sphinx_args.quiet is True:
            self.verbose = False
        if sphinx_args.jobs:
            self.n_jobs = sphinx_args.jobs
        self.n_jobs = n_jobs
        self.srctree = os.environ.get("srctree")
        if not self.srctree:
            self.srctree = "."
            os.environ["srctree"] = self.srctree
        self.sphinxbuild = os.environ.get("SPHINXBUILD", "sphinx-build")
        self.kerneldoc = self.get_path(os.environ.get("KERNELDOC",
                                                      "scripts/kernel-doc.py"))
        self.builddir = self.get_path(builddir, use_cwd=True, abs_path=True)

        self.config_rust = self.is_rust_enabled()

        self.pdflatex_cmd = shutil.which(self.pdflatex)
        self.latexmk_cmd = shutil.which("latexmk")

        self.env = os.environ.copy()

    def run_sphinx(self, sphinx_build, build_args, *args, **pwargs):
        with JobserverExec() as jobserver:
            if jobserver.claim:
                n_jobs = str(jobserver.claim)
            else:
                n_jobs = "auto" # Supported since Sphinx 1.7
            cmd = []
            cmd.append(sys.executable)
            cmd.append(sphinx_build)
            if self.n_jobs:
                n_jobs = str(self.n_jobs)

            if n_jobs:
                cmd += [f"-j{n_jobs}"]

            if not self.verbose:
                cmd.append("-q")
            cmd += self.sphinxopts
            cmd += build_args
            if self.verbose:
                print(" ".join(cmd))
            return subprocess.call(cmd, *args, **pwargs)

    def handle_html(self, css, output_dir):
        if not css:
            return
        css = os.path.expanduser(css)
        if not css.startswith("/"):
            css = os.path.join(self.srctree, css)
        static_dir = os.path.join(output_dir, "_static")
        os.makedirs(static_dir, exist_ok=True)
        try:
            shutil.copy2(css, static_dir)
        except (OSError, IOError) as e:
            print(f"Warning: Failed to copy CSS: {e}", file=sys.stderr)

    def handle_pdf(self, output_dirs):
        builds = {}
        max_len = 0
        for from_dir in output_dirs:
            pdf_dir = os.path.join(from_dir, "../pdf")
            os.makedirs(pdf_dir, exist_ok=True)
            if self.latexmk_cmd:
                latex_cmd = [self.latexmk_cmd, f"-{self.pdflatex}"]
            else:
                latex_cmd = [self.pdflatex]
            latex_cmd.extend(shlex.split(self.latexopts))
            tex_suffix = ".tex"
            has_tex = False
            build_failed = False
            with os.scandir(from_dir) as it:
                for entry in it:
                    if not entry.name.endswith(tex_suffix):
                        continue
                    name = entry.name[:-len(tex_suffix)]
                    has_tex = True
                    try:
                        subprocess.run(latex_cmd + [entry.path],
                                       cwd=from_dir, check=True)
                    except subprocess.CalledProcessError:
                        pass
                    pdf_name = name + ".pdf"
                    pdf_from = os.path.join(from_dir, pdf_name)
                    pdf_to = os.path.join(pdf_dir, pdf_name)
                    if os.path.exists(pdf_from):
                        os.rename(pdf_from, pdf_to)
                        builds[name] = os.path.relpath(pdf_to, self.builddir)
                    else:
                        builds[name] = "FAILED"
                        build_failed = True
                    name = entry.name.removesuffix(".tex")
                    max_len = max(max_len, len(name))

            if not has_tex:
                name = os.path.basename(from_dir)
                max_len = max(max_len, len(name))
                builds[name] = "FAILED (no .tex)"
                build_failed = True
        msg = "Summary"
        msg += "\n" + "=" * len(msg)
        print()
        print(msg)
        for pdf_name, pdf_file in builds.items():
            print(f"{pdf_name:<{max_len}}: {pdf_file}")
        print()
        if build_failed:
            sys.exit("PDF build failed: not all PDF files were created.")
        else:
            print("All PDF files were built.")

    def handle_info(self, output_dirs):
        for output_dir in output_dirs:
            try:
                subprocess.run(["make", "info"], cwd=output_dir, check=True)
            except subprocess.CalledProcessError as e:
                sys.exit(f"Error generating info docs: {e}")

    def cleandocs(self, builder):
        shutil.rmtree(self.builddir, ignore_errors=True)

    def build(self, target, sphinxdirs=None, conf="conf.py",
              theme=None, css=None, paper=None):
        builder = TARGETS[target]["builder"]
        out_dir = TARGETS[target].get("out_dir", "")
        if target == "cleandocs":
            self.cleandocs(builder)
            return
        if theme:
                os.environ["DOCS_THEME"] = theme
        sphinxbuild = shutil.which(self.sphinxbuild, path=self.env["PATH"])
        if not sphinxbuild:
            sys.exit(f"Error: {self.sphinxbuild} not found in PATH.\n")
        if builder == "latex":
            if not self.pdflatex_cmd and not self.latexmk_cmd:
                sys.exit("Error: pdflatex or latexmk required for PDF generation")
        docs_dir = os.path.abspath(os.path.join(self.srctree, "Documentation"))
        kerneldoc = self.kerneldoc
        if kerneldoc.startswith(self.srctree):
            kerneldoc = os.path.relpath(kerneldoc, self.srctree)
        args = [ "-b", builder, "-c", docs_dir ]
        if builder == "latex":
            if not paper:
                paper = PAPER[1]
            args.extend(["-D", f"latex_elements.papersize={paper}paper"])
        if self.config_rust:
            args.extend(["-t", "rustdoc"])
        if conf:
            self.env["SPHINX_CONF"] = self.get_path(conf, abs_path=True)
        if not sphinxdirs:
            sphinxdirs = os.environ.get("SPHINXDIRS", ".")
        sphinxdirs_list = []
        for sphinxdir in sphinxdirs:
            if isinstance(sphinxdir, list):
                sphinxdirs_list += sphinxdir
            else:
                for name in sphinxdir.split(" "):
                    sphinxdirs_list.append(name)
        output_dirs = []
        for sphinxdir in sphinxdirs_list:
            src_dir = os.path.join(docs_dir, sphinxdir)
            doctree_dir = os.path.join(self.builddir, ".doctrees")
            output_dir = os.path.join(self.builddir, sphinxdir, out_dir)
            src_dir = os.path.normpath(src_dir)
            doctree_dir = os.path.normpath(doctree_dir)
            output_dir = os.path.normpath(output_dir)
            os.makedirs(doctree_dir, exist_ok=True)
            os.makedirs(output_dir, exist_ok=True)
            output_dirs.append(output_dir)
            build_args = args + [
                "-d", doctree_dir,
                "-D", f"kerneldoc_bin={kerneldoc}",
                "-D", f"version={self.kernelversion}",
                "-D", f"release={self.kernelrelease}",
                "-D", f"kerneldoc_srctree={self.srctree}",
                src_dir,
                output_dir,
            ]
            try:
                self.run_sphinx(sphinxbuild, build_args, env=self.env)
            except (OSError, ValueError, subprocess.SubprocessError) as e:
                sys.exit(f"Build failed: {repr(e)}")
            if target in ["htmldocs", "epubdocs"]:
                self.handle_html(css, output_dir)
        if target == "pdfdocs":
            self.handle_pdf(output_dirs)
        elif target == "infodocs":
            self.handle_info(output_dirs)

def jobs_type(value):
    if value is None:
        return None
    if value.lower() == 'auto':
        return value.lower()
    try:
        if int(value) >= 1:
            return value
        raise argparse.ArgumentTypeError(f"Minimum jobs is 1, got {value}")
    except ValueError:
        raise argparse.ArgumentTypeError(f"Must be 'auto' or positive integer, got {value}")

def main():
    parser = argparse.ArgumentParser(description="Kernel documentation builder")
    parser.add_argument("target", choices=list(TARGETS.keys()),
                        help="Documentation target to build")
    parser.add_argument("--sphinxdirs", nargs="+",
                        help="Specific directories to build")
    parser.add_argument("--conf", default="conf.py",
                        help="Sphinx configuration file")
    parser.add_argument("--builddir", default="output",
                        help="Sphinx configuration file")
    parser.add_argument("--theme", help="Sphinx theme to use")
    parser.add_argument("--css", help="Custom CSS file for HTML/EPUB")
    parser.add_argument("--paper", choices=PAPER, default=PAPER[0],
                        help="Paper size for LaTeX/PDF output")
    parser.add_argument("-v", "--verbose", action='store_true',
                        help="place build in verbose mode")
    parser.add_argument('-j', '--jobs', type=jobs_type,
                        help="Sets number of jobs to use with sphinx-build")
    args = parser.parse_args()
    PythonVersion.check_python(MIN_PYTHON_VERSION)
    builder = SphinxBuilder(builddir=args.builddir,
                            verbose=args.verbose, n_jobs=args.jobs)
    builder.build(args.target, sphinxdirs=args.sphinxdirs, conf=args.conf,
                  theme=args.theme, css=args.css, paper=args.paper)

if __name__ == "__main__":
    main()
